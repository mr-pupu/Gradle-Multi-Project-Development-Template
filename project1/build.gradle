// If your build script uses external dependencies like this one uses
// spring-boot plugin you need to declare a dependency to the plugin
// in buildscript closure below.
//
// @see https://docs.gradle.org/current/userguide/organizing_build_logic.html#sec:external_dependencies
//
// Unfortunately buildscript block can't be externalized into a script plugin
// so following code is going to be duplicated in build scripts of all root
// projects.
//
// @see https://discuss.gradle.org/t/how-do-i-include-buildscript-block-from-external-gradle-script/7016/2
buildscript {
    ext {
        springBootVersion = '1.3.1.RELEASE'
    }
    repositories {
        mavenCentral()
    }
    dependencies {
        // In future we will be able to use plugins block instead of
        // buildscript. But for now we have to add plugin's classpaths.
        //
        // @see https://github.com/spring-gradle-plugins/dependency-management-plugin#using-the-plugin
        classpath "org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion}"
        classpath "io.spring.gradle:dependency-management-plugin:0.5.4.RELEASE"
    }
}

apply from: '../framework/commonConfiguration.gradle'

dependencies {
    compile project('module1')
    compile project('module2')
    // Compile dependencies on external libraries like spring-boot are get
    // transitively from the core module. On the other hand testCompile
    // dependencies does not work this way so we have to specify them in each
    // build script separately.
    //
    // Anyway it's a good practice to specify external dependencies in every
    // module and not rely on transitive dependencies like this project do.
    //
    // @see http://stackoverflow.com/questions/6023188/my-gradle-configuration-does-not-use-the-correct-classpath-during-build/10633623#10633623
    testCompile('org.springframework.boot:spring-boot-starter-test')
}

jar {
    baseName = 'project1'
    version = '0.0.1-SNAPSHOT'
}
